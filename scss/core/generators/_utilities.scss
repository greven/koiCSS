// --------------------------------
//   Utilities Generator
// --------------------------------

@use 'sass:map';
@use 'sass:list';
@use 'sass:meta';
@use 'sass:string';

@use '../api/config' as *;
@use '../api/media-query' as mq;
@use '../api/theme' as *;
@use '../helpers' as *;

$util-glue: config(utility-glue);
$use-important: config(use-important-utilities);

@mixin -create-class($properties, $local-vars, $prefix, $value) {
  @each $property in $properties {
    @if $local-vars {
      @each $local-var, $variable in $local-vars {
        --#{$prefix}#{$local-var}: #{$variable};
      }
    }

    #{$property}: $value if($use-important, !important, null);
  }
}

// Create multiple utilities from an utility map.
@mixin -utility-class($utility-map, $breakpoint: null) {
  $values: map.get($utility-map, values);
  $prefix: koi-;

  // If the values are a list or string, convert it into a map
  @if meta.type-of($values) == 'string' or meta.type-of(list.nth($values, 1)) != 'list' {
    $values: list.zip($values, $values);
  }

  @each $key, $value in $values {
    $properties: map.get($utility-map, property);
    $default-value: if(map.has-key($utility-map, default), map.get($utility-map, default), null);

    // Multiple properties are possible
    @if meta.type-of($properties) == 'string' {
      $properties: list.append((), $properties);
    }

    // Use custom class if present
    $property-class: if(map.has-key($utility-map, class), map.get($utility-map, class), list.nth($properties, 1));
    $property-class: if($property-class == null, '', $property-class);
    $property-class: str-escape($property-class);

    $property-class-modifier: if($key, if($property-class == '', '', '-') + $key, '');
    $property-class-modifier: str-escape($property-class-modifier);

    // Pseudo classes
    $state: if(map.has-key($utility-map, state), map.get($utility-map, state), ());

    $local-vars: map-get($utility-map, local-vars);

    @if $value != null {
      @if meta.type-of($value) == 'string' {
        $value: string.unquote($value);
      }

      $infix: '';
      @if $breakpoint {
        $infix: if(mq.min($breakpoint) == null, '', str-escape(#{'' + $breakpoint + $util-glue}));
      }

      // Default value
      @if $key == $default-value {
        .#{$infix + $property-class} {
          @include -create-class($properties, $local-vars, $prefix, $value);
        }
      }

      .#{$infix + $property-class + $property-class-modifier} {
        @include -create-class($properties, $local-vars, $prefix, $value);
      }

      // Pseudo States variants
      @each $pseudo in $state {
        $infix: str-escape(#{'' + $pseudo + $util-glue});

        // Default value
        @if $key == $default-value {
          .#{$infix + $property-class}:#{$pseudo} {
            @include -create-class($properties, $local-vars, $prefix, $value);
          }
        }

        .#{$infix + $property-class + $property-class-modifier}:#{$pseudo} {
          @include -create-class($properties, $local-vars, $prefix, $value);
        }
      }
    }
  }
}

// Generate utilities from a map of utility maps
@mixin generate-utilities($utilities) {
  // Generate standard utilities first
  @each $key, $utility in $utilities {
    @include -utility-class($utility);
  }

  // Maybe generate responsive utilities
  @each $breakpoint, $-value in theme(screens) {
    @include mq.from($breakpoint) {
      @each $key, $utility in $utilities {
        @if map.get($utility, responsive) {
          @include -utility-class($utility, $breakpoint);
        }
      }
    }
  }
}

// Create a single responsive utility
@mixin create-responsive-utility($class) {
  $class: str-escape($class);

  // Create standard utility first
  .#{$class} {
    @content;
  }

  // Create responsive modifiers
  @each $breakpoint, $-value in theme(screens) {
    $infix: str-escape(#{'' + $breakpoint + $util-glue});

    @include mq.from($breakpoint) {
      .#{$infix + $class} {
        @content;
      }
    }
  }
}
